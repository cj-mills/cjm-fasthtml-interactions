"""Pattern for navigation between pages of content with HTMX integration"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/patterns/pagination.ipynb.

# %% auto 0
__all__ = ['PaginationStyle', 'PaginationControls']

# %% ../../nbs/patterns/pagination.ipynb 3
from typing import Optional, Callable, Any
from enum import Enum
from fasthtml.common import *

from ..core.html_ids import InteractionHtmlIds
from cjm_fasthtml_daisyui.components.actions.button import btn, btn_sizes, btn_styles, btn_behaviors
from cjm_fasthtml_daisyui.components.navigation.pagination import join
from cjm_fasthtml_tailwind.utilities.spacing import m
from cjm_fasthtml_tailwind.utilities.flexbox_and_grid import flex_display, justify
from cjm_fasthtml_tailwind.core.base import combine_classes

# %% ../../nbs/patterns/pagination.ipynb 5
class PaginationStyle(Enum):
    """Display styles for pagination controls."""
    SIMPLE = "simple"        # Previous/Next buttons with page info
    COMPACT = "compact"      # Previous/Next buttons only (no page info)
    NUMBERED = "numbered"    # Include numbered page buttons (future enhancement)

# %% ../../nbs/patterns/pagination.ipynb 7
def PaginationControls(
    current_page: int,  # Current page number (1-indexed)
    total_pages: int,  # Total number of pages
    route_func: Callable[[int], str],  # Function to generate route for a page number
    target_id: str,  # HTML ID of element to update with HTMX
    style: PaginationStyle = PaginationStyle.SIMPLE,  # Pagination display style
    prev_text: str = "« Previous",  # Text for previous button
    next_text: str = "Next »",  # Text for next button
    page_info_format: str = "Page {current} of {total}",  # Format string for page info
    button_size: str = None,  # Button size class (e.g., btn_sizes.sm)
    container_cls: Optional[str] = None,  # Additional classes for container
    push_url: bool = True,  # Whether to update URL with hx-push-url
    **kwargs  # Additional attributes for the container
) -> FT:  # Div element with pagination controls
    """Create pagination navigation controls with HTMX integration.
    
    The controls provide Previous/Next navigation with automatic disabled states
    at page boundaries. Uses HTMX for SPA-like page transitions without full
    page reloads.
    
    Examples:
        # Simple pagination for media library
        PaginationControls(
            current_page=5,
            total_pages=20,
            route_func=lambda p: f"/library?page={p}",
            target_id="library-content"
        )
        
        # With custom styling and text
        PaginationControls(
            current_page=1,
            total_pages=10,
            route_func=lambda p: media_rt.library.to(page=p, view="grid"),
            target_id=HtmlIds.MAIN_CONTENT,
            prev_text="← Back",
            next_text="Forward →",
            button_size=str(btn_sizes.sm)
        )
        
        # Compact style without page info
        PaginationControls(
            current_page=3,
            total_pages=8,
            route_func=lambda p: f"/results?page={p}",
            target_id="results",
            style=PaginationStyle.COMPACT
        )
        
        # Without URL updates (for modals/drawers)
        PaginationControls(
            current_page=2,
            total_pages=5,
            route_func=lambda p: f"/api/items?page={p}",
            target_id="modal-content",
            push_url=False
        )
    """
    # Calculate prev/next page numbers
    prev_page = max(1, current_page - 1)
    next_page = min(total_pages, current_page + 1)
    
    # Check if we're at boundaries
    is_first_page = current_page <= 1
    is_last_page = current_page >= total_pages
    
    # Build button classes
    button_classes = [btn]
    if button_size:
        button_classes.append(button_size)
    
    # Create Previous button
    prev_button = A(
        prev_text,
        href=route_func(prev_page),
        hx_get=route_func(prev_page),
        hx_target=InteractionHtmlIds.as_selector(target_id),
        hx_swap="outerHTML",
        hx_push_url="true" if push_url else None,
        cls=combine_classes(
            *button_classes,
            btn_styles.ghost if not is_first_page else btn_behaviors.disabled
        ),
        disabled=is_first_page
    )
    
    # Create Next button
    next_button = A(
        next_text,
        href=route_func(next_page),
        hx_get=route_func(next_page),
        hx_target=InteractionHtmlIds.as_selector(target_id),
        hx_swap="outerHTML",
        hx_push_url="true" if push_url else None,
        cls=combine_classes(
            *button_classes,
            btn_styles.ghost if not is_last_page else btn_behaviors.disabled
        ),
        disabled=is_last_page
    )
    
    # Build button group content
    button_group_parts = [prev_button]
    
    # Add page info for SIMPLE style
    if style == PaginationStyle.SIMPLE:
        page_info = page_info_format.format(
            current=current_page,
            total=total_pages
        )
        button_group_parts.append(
            Span(page_info, cls=str(m.x(4)))
        )
    
    button_group_parts.append(next_button)
    
    # Build container classes
    container_classes = [
        flex_display,
        justify.center,
        m.t(6)
    ]
    if container_cls:
        container_classes.append(container_cls)
    
    # Create the pagination container
    return Div(
        Div(
            *button_group_parts,
            cls=str(join)
        ),
        cls=combine_classes(*container_classes),
        **kwargs
    )
